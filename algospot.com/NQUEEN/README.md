# Problem

[NQUEEN](https://algospot.com/judge/problem/read/NQUEEN)

# Strategy backtracking

## Idea

퀸이 놓여질 위치를 행, 열로 기억하기 위해 배열 `Q`가 필요하고
전체 경우의 수 저장을 위해 `BEST`가 필요하다.

```
int Q[]
int BEST
```

`Q[y]`는 queen의 위치중 y행의 열 값이 저장된다.  재귀적으로 해결하기
위해 다음과 같이 부분문제 `nqueen`을 정의한다.

```
bool nqueen(int y)
y      : 보드 행의 인덱스
return : y행에 퀸이 놓여질 수 잇는지 여부
```

부분 문제 `nqueen`은 다음과 같은 경우를 고려해서 재귀적으로 수행한다.

* 보드의 가로 사이즈를 `N` 이라고 하자. `y`가 `N`보다 크거나 같으면
  끝까지 탐색한 것이므로 전체 성공한 경우의 수를 하나 늘리고 true를
  리턴한다.
* `Y`가 `N`보다 작으면 열 `x`를 0부터 `N-1`까지 순회하면서 다음을
  반복한다.  `y, x`위치에 퀸을 위치할 수 있는지 검증하고 그렇다면
  `nqueen(y+1)`을 수행한다.

예를 들어서 N이 4인 경우를 생각해 보자.

```
o...
....
....
....
```

일단 `0,0`에 queen을 놓아보자. 그 다음 1행의 모든 열에 queen을
놓아보자. 이때 열 `x`를 0부터 N-1까지 순회하면서 다음을 반복한다.  
`y, x`에 queen을 위치시킬 수 있는지 검증한다. 실패하면 건너뛰자.  성공하면
`Q[y] = x` 하고 `nqueen(1)`을 수행하여 결과가 참이면 참을
리턴한다. 그렇지 않으면 `Q[y] = -1` 하고 다음 반복을
수행하자. `Q[y]`를 초기화 하고 다음을 순회 하기 때문에
backtracking이다.

`y, x`에 queen이 놓여질 수 있는 지 여부는 다음과 같은 방법을 사용한다.

* 0부터 y-1행까지 x열에 놓여진 퀸이 있으면 실패다. 예를 들어서 다음의 경우
  `y, x`가 `2,2`라고 해보자. `@` 표시 된 곳에 퀸이 놓여있는지 검사한다.

```
..@.
..@.
..o.
....
```

* 0부터 y-1행까지 `y, x`의 왼쪽 대각선에 있으면 실패다. 예를 들어서
  다음의 경우 `y, x`가 `2,2`라고 해보자. `@` 표시 된 곳에 퀸이
  놓여있는지 검사한다.

```
@...
.@..
..o.
....
```

* 0부터 y-1행까지 `y, x`의 오른쪽 대각선에 있으면 실패다. 예를 들어서
  다음의 경우 `y, x`가 `2,2`라고 해보자. `@` 표시 된 곳에 퀸이
  놓여있는지 검사한다.

```
....
...@
..o.
....
```

## Implementation

[c++11](a.cpp)

## Time Complexity

```
O(N^N)
```

# Strategy backtracking with bitmask

## Idea

## Implementation

[c++11](b.cpp)

## Time Complexity

```
O(N^N)
```
