# Problem

[NQUEEN](https://algospot.com/judge/problem/read/NQUEEN)

# Strategy backtracking

## Idea

퀸이 놓여질 위치를 행, 열로 기억하기 위해 배열 `Q`가 필요하고
전체 경우의 수 저장을 위해 `BEST`가 필요하다.

```
int Q[]
int BEST
```

`Q[y]`는 queen의 위치중 y행의 열 값이 저장된다.  재귀적으로 해결하기
위해 다음과 같이 부분문제 `nqueen`을 정의한다.

```
void nqueen(int y)
y      : 보드 행의 인덱스
```

부분 문제 `nqueen`은 다음과 같은 경우를 고려해서 재귀적으로 수행한다.

* 보드의 가로 사이즈를 `N` 이라고 하자. `y`가 `N`보다 크거나 같으면
  끝까지 탐색한 것이므로 전체 성공한 경우의 수를 하나 늘리고 종료한다.
* `Y`가 `N`보다 작으면 열 `x`를 0부터 `N-1`까지 순회하면서 다음을
  반복한다.  `(y, x)`위치에 퀸을 놓을 수 있는지 검증하고 그렇다면
  `nqueen(y + 1)`을 수행한다.

예를 들어서 N이 4인 경우를 생각해 보자.

```
o...
....
....
....
```

`(0, 0)`에 퀸이 놓여있고 현재 1행에 퀸을 놓을 상황이다.  열 `x`를
`0`부터 `N - 1`까지 순회하면서 다음을 반복한다.  `(1, x)`에 queen을
위치시킬 수 있는지 검증한다. 실패하면 건너뛰자.  성공하면 `Q[y] = x`
하고 `nqueen(2)`을 수행한다.  `Q[1] = -1` 하고 다음 반복을
수행하자. `Q[y]`를 초기화 하고 다음을 순회 하는 것은 이전 탐색으로
돌아 가서 이후의 경우의 수를 탐색하는 것이므로 backtracking이라고 할
수 있다. 그리고 특정 위치에 queen을 위치 시킬 수 없을 때 이후 탐색은
의미가 없어 건너 뛰기 때문에 pruning(가지치기)이라고 할 수 있다.

`y, x`에 queen이 놓여질 수 있는 지 여부는 다음과 같은 방법을 사용한다.

* 0부터 y-1행까지 x열에 놓여진 퀸이 있으면 실패다. 예를 들어서 다음의 경우
  `y, x`가 `2,2`라고 해보자. `@` 표시 된 곳에 퀸이 놓여있는지 검사한다.

```
..@.
..@.
..o.
....
```

* 0부터 y-1행까지 `y, x`의 왼쪽 대각선에 있으면 실패다. 예를 들어서
  다음의 경우 `y, x`가 `2,2`라고 해보자. `@` 표시 된 곳에 퀸이
  놓여있는지 검사한다.

```
@...
.@..
..o.
....
```

* 0부터 y-1행까지 `y, x`의 오른쪽 대각선에 있으면 실패다. 예를 들어서
  다음의 경우 `y, x`가 `2,2`라고 해보자. `@` 표시 된 곳에 퀸이
  놓여있는지 검사한다.

```
....
...@
..o.
....
```

## Implementation

[c++11](a.cpp)

## Time Complexity

```
O(N^N)
```

# Strategy backtracking with bitmask

## Idea

앞서 언급한 바와 backtracking with pruning전략은 똑같다.  한 발 더
나아가서 bitmask를 이용하면 더욱 효율적으로 문제를 해결 할 수
있다. 대신 bitmask를 이용하기 때문에 해결 할 수 있는 보드의 크기가
특정 숫자 이하로 제한된다.

문제를 재귀적으로 해결하기 위해 다음과 같이 부분 문제를 정의한다.

```
void nqueen(int vr, int ld, int rd)
vr : 지금까지 놓여진 queen의 수직선들의 열 값의 모임
ld : 지금까지 놓여진 queen의 왼쪽 아래 방향 대각선들의 열 값의 모임
rd : 지금까지 놓여진 queen의 오른쪽 아래 방향 대각선들의 열 값의 모임
```

vr, ld, rd를 조금 더 자세히 설명해 본다.  예를 들어서 다음과 같이 5x5
크기의 보드를 살펴보자. 1행까지 퀸을 두개 놓았고 현재 2행에 퀸을 놓을
차례이다. vr, ld, rd 는 편의상 5자리 비트시퀀스로 표현한다.

```
o....
$.o..
$@$#.
@...#
.....
```

`$`는 지금 까지 놓여진 퀸들의 수직선들의 열 값들을 표기 한
것이다. 1행에 퀸을 놓을 상황이라면 vr는 `10000`이고 2행에 퀸을 놓을
상황이라면 vr는 `10100`이다.  당연히 vr의 `1`위치에는 퀸을 놓을 수
없다. vr는 행이 증가할 때마다 새로 놓여진 퀸의 열 값이 추가
된다.

`@`는 지금 까지 놓여진 퀸들의 왼쪽 아래 방향 대각선들의 열 값들을
표기한 것이다. 2행에 퀸을 놓을 상황 이라면 ld는 `01000`이다.
2행에 퀸을 (2, 4)에 놓고 3행에 퀸을 놓을 상황이라면 ld는
`10010`이다. ld는 행이 증가할 때마다 새로 놓여진 퀸의 열 값과 함께
왼쪽으로 비트들이 이동한다.

`#`는 지금까지 놓여진 퀸들의 오른쪽 아래 방향 대각선들의 열 값들을
표기한 것이다. 2행에 퀸을 놓을 상황 이라면 rd는 `00010`이다.
2행에 퀸을 (2, 4)에 놓고 3행에 퀸을 놓을 상황이라면 rd는
`00001`이다. rd는 행이 증가할 때마다 새로 놓여진 퀸의 열 값과 함께
오른쪽으로 비트들이 이동한다.

이제 언급한 vr, ld, rd의 규칙들을 이용하여 해결 방법을 모색해 보자.
0행부터 N-1행 까지 모든 행을 순회하기 위해 부분문제 `nqueen`을 다음과
같이 재귀적으로 호출해 보자. 지금까지 놓여진 퀸들의 위치를 기반으로
만들어진 vr, ld, rd 를 모두 or 연산 하여 last를 만들어 낸다. 만약
last가 모두 1이면 즉 `11111`이면 탐색은 종료한다.

backtracking을 위해 last의 가장 오른쪽 부터 왼쪽 방향으로 0의 위치에
새로운 퀸을 놓고 last가 0이 될때 까지 다음을 반복한다.

새로운 위치를 표현하는 비트 시퀀스를 p라고 하자.  새로운 `vr`은 `vr + p`이다. 
새로운 `ld`는 `(ld + p) << 1`이다.  새로운 `rd`는 `(rd + p) >> 1`이다. 
다음행 으로 나아가기 위해 `nqueen(vr, ld, rd)` 를 수행한다.

## Implementation

[c++11](b.cpp)

## Time Complexity

```
O(N^N)
```
