# Problem

[NQUEEN](https://algospot.com/judge/problem/read/NQUEEN)

# Strategy backtracking

## Idea

퀸이 놓여질 위치를 행, 열로 기억하기 위해 배열 `Q`가 필요하고
전체 경우의 수 저장을 위해 `BEST`가 필요하다.

```
int Q[]
int BEST
```

`Q[y]`는 queen의 위치중 y행의 열 값이 저장된다.  재귀적으로 해결하기
위해 다음과 같이 부분문제 `nqueen`을 정의한다.

```
void nqueen(int y)
y      : 보드 행의 인덱스
```

부분 문제 `nqueen`은 다음과 같은 경우를 고려해서 재귀적으로 수행한다.

* 보드의 가로 사이즈를 `N` 이라고 하자. `y`가 `N`보다 크거나 같으면
  끝까지 탐색한 것이므로 전체 성공한 경우의 수를 하나 늘리고 종료한다.
* `Y`가 `N`보다 작으면 열 `x`를 0부터 `N-1`까지 순회하면서 다음을
  반복한다.  `(y, x)`위치에 퀸을 놓을 수 있는지 검증하고 그렇다면
  `nqueen(y + 1)`을 수행한다.

예를 들어서 N이 4인 경우를 생각해 보자.

```
o...
....
....
....
```

`(0, 0)`에 퀸이 놓여있고 현재 1행에 퀸을 놓을 상황이다.  열 `x`를
`0`부터 `N - 1`까지 순회하면서 다음을 반복한다.  `(1, x)`에 queen을
위치시킬 수 있는지 검증한다. 실패하면 건너뛰자.  성공하면 `Q[y] = x`
하고 `nqueen(2)`을 수행한다. 이후 `Q[1] = -1` 하고 다음 반복을
수행하자. `Q[y]`를 초기화 하고 다음을 순회 하는 것은 이전 탐색으로
돌아 가서 이후의 경우의 수를 탐색하는 것이므로 backtracking이라고 할
수 있다. 그리고 특정 위치에 queen을 위치 시킬 수 없을 때 이후 탐색은
의미가 없어 건너 뛰기 때문에 pruning(가지치기)이라고 할 수 있다.

`(y, x)`에 퀸이 놓여질 수 있는 지 여부는 다음과 같은 방법을 사용한다.

* 기존에 놓여진 퀸중에 `0`부터 `y - 1`행까지 `x`열에 놓여 있는 것이
  있다면 실패다. 예를 들어서 현재 `(2, 2)`에 퀸을 놓을 상황이라고
  해보자. `@` 표시 된 곳에 퀸이 하나 라도 놓여 있다면 `(2, 2)`에 퀸을
  놓을 수 없다.

```
..@.
..@.
..o.
....
```

* 기존에 놓여진 퀸중에 `0`부터 `y - 1`행까지 `(y, x)`의 왼쪽 위 방향
  대각선에 놓여 있는 것이 있다면 실패다. 예를 들어서 현재 `(2, 2)`에
  퀸을 놓을 상황이라고 해보자. `@` 표시 된 곳에 퀸이 하나 라도 놓여
  있다면 `(2, 2)`에 퀸을 놓을 수 없다.

```
@...
.@..
..o.
....
```

* 기존에 놓여진 퀸중에 `0`부터 `y - 1`행까지 `(y, x)`의 오른쪽 위 방향
  대각선에 놓여 있는 것이 있다면 실패다. 예를 들어서 현재 `(2, 2)`에
  퀸을 놓을 상황이라고 해보자. `@` 표시 된 곳에 퀸이 하나 라도 놓여
  있다면 `(2, 2)`에 퀸을 놓을 수 없다.

```
....
...@
..o.
....
```

## Implementation

[c++11](a.cpp)

## Time Complexity

```
O(N^N)
```

# Strategy backtracking with bitmask

## Idea

먼저 다음과 같은 자료구조가 필요하다.

```
int END;
int BEST;
// END  : 지금까지 놓여진 퀸의 위치 정보중 열의 모임
// BSET : 보드에 퀸을 놓을 수 있는 방법
```

앞서 언급한 바와 backtracking with pruning 전략은 똑같다.  한 발 더
나아가서 bitmask를 이용하면 더욱 효율적으로 문제를 해결 할 수
있다. 대신 bitmask를 이용하기 때문에 해결 할 수 있는 보드의 크기가
특정 숫자 이하로 제한된다. 만약 bitmask를 두개 이상 이용한다면 보드의
크기 제한도 극복 할 수 있다. 그러나 구현이 복잡해 질 것이다.

문제를 재귀적으로 해결하기 위해 다음과 같이 부분 문제를 정의한다.

```
void nqueen(int vr, int ld, int rd)
// vr : 지금까지 놓여진 queen의 수직선이 새로 놓을 행과 교차하는 열의 모임
// ld : 지금까지 놓여진 queen의 왼쪽 아래 방향 대각선이 새로 놓을 행과 교차하는 열의 모임
// rd : 지금까지 놓여진 queen의 오른쪽 아래 방향 대각선이 새로 놓을 행과 교차하는 열의 모임
```

부분 문제 `nqueen` 의 매개변수에 대해 조금 더 자세히 설명해 본다.
예를 들어서 다음과 같이 `5 x 5` 크기의 보드를 살펴보자. 1행까지 퀸을
두개 놓았고 현재 2행에 퀸을 놓을 차례이다. `vr`, `ld`, `rd` 는 편의상
5자리 비트시퀀스로 표현한다.

```
o....
$.o..
$.$..
$.$..
$.$..
```

`$`는 지금 까지 놓여진 퀸의 수직선을 표현 한 것이다.  수직선이 새로
놓을 행과 교차했을 때 열의 모음을 `vr`이라고 하자.  1행에 퀸을 놓을
상황이라면 `vr`는 `10000`이고 2행에 퀸을 놓을 상황이라면 `vr`는
`10100`이다.  당연히 `vr`의 비트시퀀스 중 `1`위치에는 퀸을 놓을 수
없다. `vr`는 행이 증가할 때마다 새로 놓여진 퀸의 열 값이 추가 된다.

```
o....
..o..
.@...
@....
.....
```

`@`는 지금 까지 놓여진 퀸의 왼쪽 아래 방향 대각선을 표현 한 것이다.
대각선이 새로 놓을 행과 교차했을 때 열의 모음을 `ld`이라고 하자.
1행에 퀸을 놓을 상황이라면 `ld`는 `00000`이고 2행에 퀸을 놓을 상황
이라면 `ld`는 `01000`이다. `(2, 4)`에 퀸을 놓고 3행에 퀸을 놓을
상황이라면 `ld`는 `10010`이다. 당연히 `ld`의 비트시퀀스 중 `1`위치에는
퀸을 놓을 수 없다. `ld`는 행이 증가할 때마다 새로 놓여진 퀸의 열 값과
함께 더해진 다음 왼쪽으로 모든 비트들이 이동한다.

```
o....
.#o..
..##.
...##
....#
```

`#`는 지금까지 놓여진 퀸들의 오른쪽 아래 방향 대각선을 표현 한 것이다.
대각선이 새로 놓을 행과 교차했을 때 열의 모음을 `rd`이라고 하자.
1행에 퀸을 놓을 상황이라면 `rd`는 `01000`이고 2행에 퀸을 놓을 상황
이라면 `rd`는 `00110`이다.  `(2, 4)`에 퀸을 놓고 3행에 퀸을 놓을
상황이라면 `rd`는 `00011`이다.  당연히 `rd`의 비트시퀀스 중 `1`위치에는
퀸을 놓을 수 없다. `rd`는 행이 증가할 때마다 새로 놓여진 퀸의 열 값과
함께 더해진 다음 오른쪽으로 모든 비트들이 이동한다.

이제 앞서 언급한 규칙들을 이용해서 부분 문제 `nqueen`을 다음과 같은
경우를 고려하여 재귀적으로 수행한다.

* `vr`의 모든 비트들이 1이라면 모든 퀸을 놓은 것이므로 `BEST`를
  하나 증가하고 종료한다.
* `vr`, `ld`, `rd`를 모두 `OR`연산 하고 비트들을 반대로 뒤집는다.
  그러면 비트시퀀스 중 `1`의 위치에 퀸을 놓을 수 있게 된다. 이것을
  `last`에 저장하자. `last`가 0이 될때 까지 다음을 반복한다.
  * `last`의 비트 중 가장 오른쪽 `1`을 골라와서 이것을 `pos`에
    저장하자. `pos`는 새로 놓일 퀸의 열을 의미한다. `last`에서
    제거되야 한다. 그리고 부분 문제 `nqueen`을 호출한다. 새로운 `vr`은
    기존의 `vr`에 `pos`를 더한 것과 같다. 새로운 `ld`는 기존의 `ld`에
    `pos`를 더한 다음 왼쪽으로 모든 비트를 이동한 것과 같다. 새로운
    `rd`는 기존의 `rd`에 `pos`를 더한 다음 오른쪽으로 모든 비트를
    이동한 것과 같다.

## Implementation

[c++11](b.cpp)

## Time Complexity

```
O(N^N)
```
