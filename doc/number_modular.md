# Abstract

나머지 연산자 %에 대해 적는다.

# Add

두 정수 a + b를 M으로 나눈 나머지를 구해보자.

```
a = xM + a'
b = yM + b'
a + b = (x + y)M + (a' + b')
a + b를 M으로 나눈 나머지는 a' + b'을 M으로 나눈 나머지와 같다.
(a + b) % M = ((a % M) + (b % M)) % M
```

A[]에 담겨있는 정수들을 모두 더하고 마지막 여덟자리를 구해 보자. 위의
%의 덧셈 성질을 활용해 보자. A[]를 차례대로 순회하면서 각 원소에 대해
10^8으로 나눈 후 나머지를 더해간다. 두수를 더할 경우 다시 10^8으로
나누어 나머지를 다음 덧셈에 이용한다. 

다음 코드를 참고하자. A[]는 64bit의 정수들이 담겨
있지만 32bit정수를 이용하여 10^8으로 나눈 나머지를
문제 없이 구할 수 있다.

```c
long A[N];
int r = 0;

for (int i = 0; i < N; ++i) {
  r += A[i] % sizeof(int);
  r %= sizeof(int);
}

```

# Sub

```
(a - b) % M = ((a % M) - (b % M)) % M```
```

# Mul

```
(a X b) % M = ((a % M) X (b % M)) % M```
```

# Div

나머지 연산자의 덧셈, 뺄셈, 곱셈은 비슷하지만 나눗셈은
다르다. 나눗셈은 곱셈으로 표현할 수 있는 점을 이용하자.  a / b의 경우
b로 나누는 대신 b의 곱셈역원(multiplicative inverse)를 곱하자.
b의 곱셈역원은 페르마의 소정리(Fermat's Little Theorem)을
이용하여 다음과 같은 방법으로 구한다.

```
modinv(b, M) = b^{M-2} % M
```

따라서 나눗셈에 대한 나머지 연산자는 다음과 같이 해결한다.

```
(a / b) % M = (a X modinv(b, M)) % M
```

