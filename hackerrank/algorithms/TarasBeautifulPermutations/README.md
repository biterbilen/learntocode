# Problem

[Tara's beautiful permutations](https://www.hackerrank.com/challenges/taras-beautiful-permutations/problem)

# Idea

숫자의 종류는 문제가 되지 않는다. 예를 들어서 `{1,1,2}`의 답과
`{2,2,4}`의 답은 같다. 그렇다면 무엇 때문에 두 경우의 답은 같을까?
한번 등장하는 숫자의 수를 i라 하고 두번 등장하는 숫자의 수를 j라 하면
앞서 언급한 두 경우 `i,j = 1,2` 이기 때문에 서로의 답이 같다.

따라서 숫자의 종류보다는 i,j를 고려해서 캐시를 구성하면 테스트 케이스가
굉장히 많을때 시간 복잡도를 줄일 수 있다.

다음과 같은 경우를 조금 더 생각해 보자. A가 `{1,1,2,2,3,4}` 일때
`i,j = 2,2`이다. A에서 숫자가 하나 빠진 경우를 A'라고 하자.  A'에서
숫자 하나를 더해서 A가 되는 모든 경우의 수 들을 생각해보자.  이것 에서
규칙을 발견 할 수 있다면 재귀적으로 문제를 해결 할 수 있다.

첫번째는 i가 하나 감소한 경우이다. 예를 들어서 `{1,1,2,2,3}`에서 `i,j = 1,2` 이다. 
만약 `4`가 추가 된다면 `{1,1,2,2,3,4}`이고 `i,j = 2,2` 이다. 
두번째는 j가 하나 감소하고 i가 하나 증가한 경우이다. 예를 들어서
`{1,1,2,3,4}`에서 `i,j = 3,1` 이다. 만약 `2`가 추가 된다면
`1,1,2,2,3,4`이고 `i,j = 2,2` 이다.

이제 `{1,1,2,2,3,4}`의 답을 `S({1,1,2,2,3,4})`라고 정의하면 다음과
같이 모든 경우의 수를 만들어 낼 수 있다.

```
S({1,1,2,2,3,4} = S({1,1,2,2,3} + S({1,1,2,2,4}) + 
                  S({1,2,2,3,4} + S({1,1,2,3,4})
```

이 것을 `i,j`의 표현으로 바꾸어 보자.

```
S(2,2) = S(1,2) + S(1,2) + S(3,1) + S(3,1)
       = S(1,2) * 2 + S(3,1) * 2
S(3,1) = S(2,1) + S(2,1) + S(4,0)
       = S(2,1) * 2 + S(4,0) * 1
```

부분 문제 S의 의미가 좀 더 명확해 졌다.
즉 `S(i, j) = S(i - 1, j) * i + S(i + 1, j - 1) * j`와 같다.  
그러나 어떤 경우는 `S(i, j) = S(i - 1, j) * (i - 1) + S(i + 1, j - 1) * j`와 같다. 
`i` 대신 `i - 1`을 사용 했음을 주목 하자. 

마지막으로 base condition에 대해 고민해야 한다.

```
S( 0, 0) = 0
S( 0, 1) = 0
S(-1, ?) = 0
S( ?,-1) = 0
S( 1, 0) = 1
```

# Implementation

[c++11](a.cpp)

# Time Complexity

