# Problem

[Tara's beautiful permutations](https://www.hackerrank.com/challenges/taras-beautiful-permutations/problem)

# Idea

숫자의 종류는 문제가 되지 않는다. 예를 들어서 `{1,1,2}`의 답과
`{2,2,4}`의 답은 같다. 그렇다면 무엇 때문에 두 경우의 답이 같을까?
한번 등장하는 숫자의 수를 i라 하고 두번 등장하는 숫자의 수를 j라 하면
앞서 언급한 두 숫자들은 `i,j = 1,2` 로 같기 때문에 서로의 답이 같다.

따라서 숫자의 종류보다는 i,j를 기준으로 경우의 수를 만들어 문제를
해결해야 한다.

다음과 같은 예를 조금 더 생각해 보자. A가 `{1,1,2,2,3,4}` 일때
`i,j = 2,2`이다. A에서 숫자가 하나 빠진 경우를 A'라고 하자.  A'에서
숫자 하나를 더해서 A가 되는 모든 경우의 수 들을 생각해보자.  이것 에서
규칙을 발견 할 수 있다면 부분 문제를 정의하여 재귀적으로 문제를 해결 할 수 있다.

첫번째는 i가 하나 감소한 경우이다. 예를 들어서 `{1,1,2,2,3}`는 `i,j = 1,2` 이다. 
만약 `4`가 추가 된다면 A가 될 수 있다. `{1,1,2,2,4}`는 `i,j = 1,2` 이다. 
만약 `3`이 추가 된다면 역시 A가 될 수 있다. 그외의 경우는 생각 할 수 없다.
두번째는 j가 하나 감소하고 i가 하나 증가한 경우이다. 예를 들어서
`{1,1,2,3,4}`는 `i,j = 3,1` 이다. 만약 `2`가 추가 된다면 A가 될 수 있다.
`{1,2,2,3,4}`는 `i,j = 3,1` 이다. 만약 `1`가 추가 된다면 A가 될 수 있다.

이제 `{1,1,2,2,3,4}`의 답을 `S({1,1,2,2,3,4})`라고 정의하면 
다음과 같은 전개식을 만들어 낼 수 있다.

```
S({1,1,2,2,3,4} = S({1,1,2,2,3} + S({1,1,2,2,4}) + 
                  S({1,2,2,3,4} + S({1,1,2,3,4})
S({1,2,2,3,4})  = S({1,2,2,3}) + S({1,2,2,4}) + // S({2,2,3,4})는 불가능하다.
                  S({1,2,3,4}) 
```

이때 주의해야 할 것이 있다. 위의 전개식에서 `S({1,2,2,3,4})`를 살펴보자.
`S({2,2,3,4})`는 전개식에서 제거 되어 있다.

이 것을 `i,j`의 표현으로 바꾸어 보자.

```
S(2,2) = S(1,2) + S(1,2) + 
         S(3,1) + S(3,1)
       = S(1,2) * 2 + S(3,1) * 2
S(3,1) = S(2,1) + S(2,1) + 
         S(4,0)
       = S(2,1) * 2 + S(4,0) * 1
```

부분 문제 S의 의미가 좀 더 명확해 졌다.
즉 `S(i, j) = S(i - 1, j) * i + S(i + 1, j - 1) * j`와 같다.  
그러나 어떤 경우는 `S(i, j) = S(i - 1, j) * (i - 1) + S(i + 1, j - 1) * j`와 같다. 
`i` 대신 `i - 1`을 사용 했음을 주목 하자. 

마지막으로 `S({1,1,2})`를 살펴보자.

```
S(1,1,0) = S(0,1,0) * 1 +
           S(2,0,1) * 1
 S(0,1,0) = S(-1,1,0) * 0 +
            S(1,0,1) * 1
 S(2,0,1) = 
```

```
S( 0, 0) = 0
S( 0, 1) = 0
S(-1, ?) = 0
S( ?,-1) = 0
S( 1, 0) = 1
```

# Implementation

[c++11](a.cpp)

# Time Complexity

